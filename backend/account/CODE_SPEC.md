# バックエンドコード仕様

## アーキテクチャ

### クリーンアーキテクチャの採用

- 以下の層で構成されるクリーンアーキテクチャを採用します：
  1. **インターフェース層** (handler)
  2. **ユースケース層** (usecase)
  3. **ドメイン層** (domain)
  4. **インフラストラクチャ層** (repository)

### 依存関係の方向

- 外側の層は内側の層に依存する
- 内側の層は外側の層に依存しない
- 依存性は常に内側に向かう

## ディレクトリ構造

```
domain/
├── api/          # API定義ファイル
├── app/          # アプリケーションのセットアップとDI
├── config/       # 設定関連
├── env/          # 環境変数管理
├── gen/          # 自動生成コード
├── handler/      # HTTPハンドラ
├── repository/   # データアクセス
├── sqlc/         # SQLC設定とクエリ
├── transaction/  # トランザクション管理
├── usecase/      # ビジネスロジック
└── util/         # ユーティリティ
```

## 命名規則

### パッケージ名

- 小文字の単数形を使用
- 略語は避け、完全な単語を使用
  - 例：`repository`, `usecase`, `handler`

### インターフェース名

- インターフェース名は「er」で終わる
  - 例：`Repository`, `Handler`, `UseCase`

### 実装名

- インターフェースの実装クラスは「Impl」で終わる
  - 例：`RepositoryImpl`, `HandlerImpl`, `UseCaseImpl`

### ファイル名

- 小文字のスネークケースを使用
- 機能を表す名詞を使用
  - 例：`user_repository.go`, `auth_handler.go`
- テストファイルは実装ファイルと同じディレクトリに配置
  - テストファイル名は実装ファイル名に`_test`を付加
  - 例：`user_repository.go` → `user_repository_test.go`

## エラーハンドリング

### エラー定義

- ドメイン固有のエラーは`domain/errors`パッケージに定義
- エラーは`errors.New()`で作成し、`fmt.Errorf()`でラップ
- エラーコードは大文字のスネークケースで定義
  - 例：`INVALID_USER_ID`, `USER_NOT_FOUND`

### エラー返却

- エラーは必ずラップして返却
- エラーメッセージは具体的で説明的な内容に
- エラーレスポンスの形式
  ```json
  {
    "status": "error",
    "error": {
      "code": "ERROR_CODE",
      "message": "エラーメッセージ",
      "details": {
        // エラーの詳細情報（オプション）
      }
    }
  }
  ```

### エラーログ

- エラー発生時は必ずログに記録
- ログには以下の情報を含める
  - エラーコード
  - エラーメッセージ
  - スタックトレース
  - リクエストID（存在する場合）
  - 関連するコンテキスト情報

## データベース

### トランザクション管理

- トランザクションはユースケース層で管理
- トランザクション境界はユースケースの関数境界と一致

### クエリ生成

- SQLクエリは`gen`パッケージで自動生成
- 手動のSQLクエリは避ける

## 依存性注入

### DIコンテナ

- `github.com/samber/do`を使用
- 依存関係は`app`パッケージで一元管理

### 依存関係の定義

- インターフェースは実装と分離
- 依存関係はインターフェースを通じて注入

## 環境変数

### 環境変数の管理

- 環境変数は`env`パッケージで一元管理
- デフォルト値は必ず設定

### 環境変数の命名

- 環境変数名は大文字のスネークケース
- プレフィックスはドメイン名を使用
  - 例：`ACCOUNT_DB_HOST`, `ACCOUNT_DB_PORT`

## ロギング

### ログライブラリ

- `zap`を使用
- ロガーは`util/logger`パッケージで一元管理
- ロガーの初期化は`app`パッケージで行う

### ログレベル

- ERROR: エラー発生時
  - アプリケーションの動作に影響するエラー
  - データの整合性が損なわれる可能性があるエラー
- INFO: 重要な処理の開始・終了
  - アプリケーションの起動・終了
  - 重要なビジネスロジックの実行
- DEBUG: デバッグ情報
  - 開発時のデバッグに必要な情報
  - パフォーマンス計測情報

### ログフォーマット

- 構造化ログを使用
- 以下のフィールドを含める
  - `timestamp`: ISO8601形式のタイムスタンプ
  - `level`: ログレベル
  - `message`: ログメッセージ
  - `request_id`: リクエストID（存在する場合）
  - `user_id`: ユーザーID（存在する場合）
  - `trace_id`: トレースID（存在する場合）
  - `span_id`: スパンID（存在する場合）
  - `error`: エラー情報（エラーレベルの場合）

### ログ出力先

- 開発環境: 標準出力（JSON形式）
- 本番環境: ファイル出力（JSON形式）
  - ログローテーションを設定
  - エラーログは別ファイルに出力

## セキュリティ

### 認証・認可

- JWTを使用した認証
- ロールベースのアクセス制御

### データ保護

- パスワードはハッシュ化して保存
- 機密情報は環境変数で管理

## テスト

### テストの種類

1. **ユニットテスト**
   - 個々の関数やメソッドのテスト
   - 依存関係はモック化

2. **インテグレーションテスト**
   - 複数コンポーネントの連携テスト
   - 実際のデータベースを使用

### テストデータ

- テストデータは`config/test_data.go`で管理
- テストデータはテストケースごとにクリーンアップ

## ドキュメント

### コードコメント

- パッケージ、型、関数には必ずコメントを付ける
- コメントは日本語で記述

### API仕様

#### APIドキュメントの配置

- APIエンドポイントの仕様は`docs/api.md`に記述
- 各ドメイン固有のAPI仕様は`docs/{domain}/api.md`に記述
  - 例：`docs/account/api.md`, `docs/image/api.md`
- API定義ファイルは`api`ディレクトリに配置
  - OpenAPI/Swagger定義
  - gRPC定義（使用する場合）

#### API仕様の記述形式

1. **エンドポイントの基本情報**
   ```markdown
   ## エンドポイント名

   ### 概要
   - エンドポイントの目的と機能の説明
   - 認証の要否
   - 権限要件

   ### エンドポイント
   ```
   {HTTPメソッド} /api/v1/{ドメイン}/{リソース}/{アクション}
   ```

   ### パラメータ
   | パラメータ名 | 型 | 必須 | 説明 |
   |------------|-----|------|------|
   | param1 | string | ○ | パラメータの説明 |
   | param2 | number | × | パラメータの説明 |

   ### リクエスト例
   ```json
   {
     "key1": "value1",
     "key2": "value2"
   }
   ```

   ### レスポンス例
   ```json
   {
     "status": "success",
     "data": {
       "key1": "value1",
       "key2": "value2"
     }
   }
   ```

   ### エラーレスポンス
   ```json
   {
     "status": "error",
     "error": {
       "code": "ERROR_CODE",
       "message": "エラーメッセージ"
     }
   }
   ```
   ```

2. **共通レスポンス形式**
   - 成功時
     ```json
     {
       "status": "success",
       "data": {
         // レスポンスデータ
       },
       "meta": {
         // メタデータ（オプション）
         "request_id": "string",
         "timestamp": "ISO8601形式のタイムスタンプ"
       }
     }
     ```
   - エラー時
     ```json
     {
       "status": "error",
       "error": {
         "code": "ERROR_CODE",
         "message": "エラーメッセージ",
         "details": {
           // エラーの詳細情報（オプション）
         }
       },
       "meta": {
         // メタデータ（オプション）
         "request_id": "string",
         "timestamp": "ISO8601形式のタイムスタンプ"
       }
     }
     ```

3. **HTTPステータスコード**
   - 200: 成功
   - 201: 作成成功
   - 400: バリデーションエラー
   - 401: 認証エラー
   - 403: 権限エラー
   - 404: リソース未発見
   - 409: 競合エラー
   - 422: バリデーションエラー（詳細）
   - 429: レート制限超過
   - 500: サーバーエラー
   - 503: サービス利用不可

4. **認証・認可**
   - 認証が必要なエンドポイントには`Authorization`ヘッダーを必須とする
   - トークン形式: `Bearer {JWT_TOKEN}`
   - 権限レベルに応じたアクセス制御を実装

5. **バリデーション**
   - リクエストパラメータの型チェック
   - 必須項目のチェック
   - 値の範囲チェック
   - カスタムバリデーションルール

6. **レート制限**
   - エンドポイントごとの制限回数を設定
   - レート制限超過時のレスポンス形式
   ```json
   {
     "status": "error",
     "error": {
       "code": "RATE_LIMIT_EXCEEDED",
       "message": "レート制限を超過しました",
       "retry_after": 60
     }
   }
   ```

7. **バージョニング**
   - URLパスにバージョンを含める
   - 例：`/api/v1/account/users`
   - メジャーバージョンの変更時は新しいエンドポイントを作成

8. **ページネーション**
   - リスト系APIにはページネーションを実装
   - クエリパラメータ
     - `page`: ページ番号（1から開始）
     - `limit`: 1ページあたりの件数
   - レスポンス形式
   ```json
   {
     "status": "success",
     "data": {
       "items": [...],
       "pagination": {
         "current_page": 1,
         "total_pages": 10,
         "total_items": 100,
         "has_next": true
       }
     }
   }
   ```

9. **ソート**
   - ソート可能な項目を明示
   - クエリパラメータ
     - `sort`: ソート項目
     - `order`: ソート順（asc/desc）

10. **フィルタリング**
    - フィルタリング可能な項目を明示
    - クエリパラメータで条件を指定
    - 複数条件の組み合わせに対応

11. **検索**
    - 全文検索が必要な場合は専用のエンドポイントを用意
    - 検索パラメータの詳細な仕様を記述

12. **ファイルアップロード**
    - マルチパートフォームデータを使用
    - ファイルサイズ制限を明示
    - 許可するファイル形式を明示

13. **WebSocket**
    - WebSocketを使用する場合は接続手順を記述
    - メッセージフォーマットを定義
    - エラーハンドリング方法を記述

## バージョン管理

### ブランチ戦略

- main: 本番環境用
- develop: 開発環境用
- feature/*: 機能開発用
- hotfix/*: 緊急バグ修正用

### コミットメッセージ

- プレフィックス: feat, fix, docs, style, refactor, test, chore
- 日本語で具体的な内容を記述 